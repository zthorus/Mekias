; MEKIAS (assembler inside Basic)
; ===============================

; Written by S. Morel in (circa) 1986
; Reversed-engineered by himself in 2016 and in 2026 ;-)

; Quick user guide:
; - Mekias code is put in REM lines of BASIC
; - Make sure there is no space char between line number and REM 
;   (bug in the ZXSP emulator introduces space chars)
; - First line of Mekias code must be:
;   {<ORG val in decimal>
;   (e.g.: {30000 )
; - Last line of Mekias code must be:
;   }
; - Labels for jumps and calls at current address are defined by:
;   *<label>* 
; - Labels can be assigned a value that is not the current address:
;   *<label>*=<value in decimal>
; - Maximum length of labels is 7 characters
; - Comments can normally be appended to a line of Mekias code. They are supposed to start with
;   the ; character.
; - Constant values can be defined at the current address by:
;   #<value in decimal>
;   %<value in binary>
;   $<character string>
; - A BASIC REM line can contain several instructions (mnemonics, label definitions,
;   constant definitions) if they are separated by the ' character.
; - Code is compiled whenever the RUN command is typed.
; - Space characters in mnemonics are optional and are ignore (you can write LDA,(DE) or
    LD A,(DE)).
; - The Z80 instructions using the IX and IY registers (prefixed by xDD and xFD) are not 
    implemented.    

; Mekias can be (mostly) relocated thanks to a table for jumps and calls
; This table is always located at adress 23496 when Mekias is installed.
; In the disassembled code below, Mekias was relocated at address 40000.  

; Tables of mnemonic start at 41560. Each table ends with a ! character.

; Addresses of relevant variables:
; 23296: buffer containing the instruction to be parsed (16 bytes) .
; 23312: buffer containing the mnemonic to be found in table (16 bytes).
; 23328: buffer containing label being read (7 bytes), or numerical argument of current op-code.
; 23344: number of digits in parsed string that represents a number (1 byte).
; 23345: pointer to current op-code to be written, eq. to PC (2 bytes).
; 23347: currently-parsed BASIC line number (2 bytes).
; 23349: value of op-code found (1 byte). 
; 23350: address of end of label table (2 bytes).
; 23352: =1 if ORG defined (1 byte).
; 23355: type of argument in instruction (0 = no, number or label).
; 23356: =255 if used-label being read, 0 otherwise (1 byte).
; 23357: pointer to label-length field in label table (1 byte). 
; 23359: address of beginning of label table (2 bytes).
; 23361: pointer to label to be resolved (2 bytes).
: 23364: auxiliary pointer to BASIC source code, also used for label resolution (2 bytes).
; 23366: main pointer to BASIC source code (2 bytes).

; Addresses of relevant constants
; 23370 table of op-codes using a 1-byte argument.

; Character strings of error messages (in french) that can be displayed start at 23395.
; The address of each message string is: 91*256 + code
; Error codes are:
; 99: ORG not defined.
; 110: Invalid number.
; 125: Label too long.
; 141: Line too long.
; 159: Invalid mnemonic.
; 173: Label not defined.

; 23484: table of Z80 registers used in BIT instructions.
; 23681: flag indicating if compilation has already been done

; MEKIAS CODE STARTS HERE
; 

; Table used for code relocation (case of relocation of main code at 40000)

        23496  c3 40 9c     JP 40000 ; multiplication
        23499  c3 4b 9c     JP 40011 ; string-to-number conversion 
        23502  c3 fd a0     JP 41213 ; BASIC-line analysis 
        23505  c3 97 9c     JP 40087 ; constant string storage 
        23508  c3 b1 9c     JP 40113 ; constant decimal number storage 
        23511  c3 d5 9c     JP 40149 ; constant binary number storage 
        23514  c3 0d 9d     JP 40205 ; error message display 
        23517  c3 38 9d     JP 40248 ; BIT/RES/SET parsing 
        23520  c3 76 9d     JP 40310 ; label-definition parsing 
        23523  c3 d0 9d     JP 40400 ; mnemonic-table search 
        23526  c3 0b 9      JP 40459 ; line buffer parsing
        23529  c3 f4 9f     JP 40948 ; start label resolution 
        23532  c3 08 a0     JP 40968 ; resolve next label

; Interrupt routine (called every 20 ms)

         39679  01 9b ff   LD BC,65435   ; ?
         39682  f3         DI
         39683  f5         PUSH AF
         39684  e5         PUSH HL
         39685  c5         PUSH BC
         39686  d5         PUSH DE
         39687  2a 59 5c   LD HL,(23641)
         39690  7e         LD A,(HL)
         39691  fe f7      CP 247         ; check if 1st character in command line is RUN
         39693  20 0f      JR NZ,15 LBLA
         39695  3a 81 5c   LD A,(23681)   ; check if compilation not done yet
         39698  fe 00      CP 0
         39700  cc c3 a0   CALL Z,41155   ; start compilation
         39703  3e 01      LD A,1         ; flag compilation as done
         39705  32 81 5c   LD (23681),A
         39708  18 05      JR 5 LBLB
LBLA     39710  3e 00      LD A,0         ; flag compilation as not done yet
         39712  32 81 5c   LD (23681),A
LBLB     39715  d1         POP DE
         39716  c1         POP BC
         39717  e1         POP HL
         39718  f1         POP AF
         39719  fb         EI
         39720  c9         RET
         39721  3e 9a      LD A,154       ; set address of interrupt routine = 154*256 + x
         39723  ed 47      LD I,A         ; (note from 154*256=39424 to 39678: zone with NOPs) 
         39725  ed 5e      IM 2
         39727  c9         RET

; Routine to multiply number in BC by digit (ASCII char) indexed by DE
; Add result to initial value of HL. 

        40000  1a           LD A,(DE)
        40001  d6 30        SUB 48 ; convert ASCII to number (<10)
        40003  28 04        JR Z,4 LBL0
LBL1    40005  09           ADD HL,BC
        40006  3d           DEC A
        40007  20 fc        JR NZ,252 LBL1
LBL0    40009  13           INC DE            ; move to next digit
        40010  c9           RET

; Routine to convert to number string addresed by DE corresponding to number
; (decimal) set carry flag if conversion OK and return result in HL

        40011  d5           PUSH DE
        40012  0e 00        LD C,0        ; count number of digits
LBL3    40014  1a           LD A,(DE)     ; return it in C
        40015  d6 30        SUB 48
        40017  fe 0a        CP 10
        40019  30 04        JR NC,4 LBL2  ; character is not a digit => end of number
        40021  0c           INC C
        40022  13           INC DE
        40023  18 f5        JR 245 LBL3
LBL2    40025  79           LD A,C
        40026  32 30 5b     LD (23344),A  ; store number of digits
        40029  d1           POP DE
        40030  21 00 00     LD HL,0       ; initialize number to 0
        40033  fe 05        CP 5         
        40035  28 12        JR Z,18 LBL4
        40037  fe 04        CP 4
        40039  28 14        JR Z,20 LBL5
        40041  fe 03        CP 3
        40043  28 16        JR Z,22 LBL6
        40045  fe 02        CP 2
        40047  28 18        JR Z,24 LBL7
        40049  fe 01        CP 1
        40051  28 1a        JR Z,26 LBL8
        40053  a7           AND A          ; too many digits => wrong number, set CF to 0
        40054  c9           RET
LBL4    40055  01 10 27     LD BC,10000   ; number >= 10000
        40058  cd c8 5b     CALL 23496    ; get HL = 1st digit*10000
LBL5    40061  01 e8 03     LD BC,1000    ; same for the following digits \
        40064  cd c8 5b     CALL 23496    ; (cumulating into HL)
LBL6    40067  01 64 00     LD BC,100
        40070  cd c8 5b     CALL 23496
LBL7    40073  01 0a 00     LD BC,10
        40076  cd c8 5b     CALL 23496
LBL8    40079  01 01 00     LD BC,1
        40082  cd c8 5b     CALL 23496
        40085  37           SCF           ; set CF to 1 ( conversion OK)
        40086  c9           RET           ; return number in HL

; Routine to store a constant string at current compiled-code pointer (eq to PC)
; Dots ('.') are replaced by space characters (since space characters are not copied 
; into the instruction buffer) 

        40087  11 01 5b     LD DE,23297    ; start at 2nd character in buffer
        40090  2a 31 5b     LD HL,(23345)  ; 23345 = address of PC
LBL10   40093  1a           LD A,(DE)
        40094  fe 00        CP 0           ; check of end of line reached \
        40096  ca ce 5b     JP Z,23502     ; if so, analyze next instruction
        40099  fe 2e        CP 46          ; if dot, replace it by space
        40101  20 02        JR NZ,2 LBL9
        40103  3e 20        LD A,32
LBL9    40105  77           LD (HL),A      ; write character of string at PC
        40106  13           INC DE
        40107  23           INC HL
        40108  22 31 5b     LD (23345),HL   ; update PC
        40111  18 ec        JR 236 LBL10

; Routine to store a constant number (given in decimal as a string) at
; current compiled code pointer (eq to PC) 

        40113  11 01 5b     LD DE,23297     ; start at 2nd char in buffer
        40116  cd cb 5b     CALL 23499      ; convert string into number
        40119  38 05        JR C,5 LBL11
        40121  2e 6e        LD L,110        ; err code = invalid number
        40123  c3 da 5b     JP 23514        ; display error message
LBL11   40126  eb           EX DE,HL
        40127  2a 31 5b     LD HL,(23345)
        40130  73           LD (HL),E
        40131  23           INC HL
        40132  22 31 5b     LD (23345),HL
        40135  7a           LD A,D
        40136  fe 00        CP 0            ; if 8-bit number, stop here \ 
        40138  ca ce 5b     JP Z,23502      ; and analyze next instruction
        40141  72           LD (HL),D       ; write MS (if number > 255)
        40142  23           INC HL
        40143  22 31 5b     LD (23345),HL   ; update PC
        40146  c3 ce 5b     JP 23502        ; analyze next instruction

; Routine to store a constant number (given in binary as a string) at
; current compiled code pointer (eq to PC)
; since binary is useful to define graphic characters or sprites,
; the '0' can be represented by '.' in Mekias assembler

        40149  11 10 5b     LD DE,23312    ; search for the end of the line \
LBL13   40152  1a           LD A,(DE)      ; in the buffer
        40153  fe 00        CP 0
        40155  20 03        JR NZ,3 LBL12
        40157  1b           DEC DE
        40158  18 f8        JR 248 LBL13
LBL12   40160  21 00 00     LD HL,0
        40163  01 01 00     LD BC,1
LBL15   40166  1a           LD A,(DE)       ; convert string representing binary \
        40167  fe 31        CP 49           ; into number from right to left
        40169  20 01        JR NZ,1 LBL14   ; 49 = ASCII code of 1
        40171  09           ADD HL,BC       ; (any other character means 0)
LBL14   40172  1b           DEC DE          ; go to character on the left
        40173  cb 21        SLA C           ; multiply BC by 2
        40175  cb 10        RL B
        40177  7b           LD A,E
        40178  fe 00        CP 0            ; E = 0 => beginning of line buffer reached
        40180  20 f0        JR NZ,240 LBL15
        40182  eb           EX DE,HL
        40183  2a 31 5b     LD HL,(23345)   
        40186  73           LD (HL),E       ; write LS of number at PC
        40187  23           INC HL
        40188  22 31 5b     LD (23345),HL   ; update PC
        40191  7a           LD A,D
        40192  fe 00        CP 0            ; if number to store < 256 \
        40194  ca ce 5b     JP Z,23502      ; go to analyze next instruction
        40197  72           LD (HL),D       ; write MS if num > 255
        40198  23           INC HL
        40199  22 31 5b     LD (23345),HL   ; update PC
        40202  c3 ce 5b     JP 23502        ; analyze next instruction

; Routine to display error message at the bottom of screen
; HL=address of message buffer

        40205  e5           PUSH HL
        40206  3e 02        LD A,2
        40208  cd 01 16     CALL 5633       ; open channel#2 = bottom of screen
        40211  cd 6b 0d     CALL 3435       ; do a CLS
        40214  e1           POP HL
        40215  26 5b        LD H,91
LBL17   40217  23           INC HL
        40218  7e           LD A,(HL)
        40219  fe 0d        CP 13
        40221  28 03        JR Z,3 LBL16
        40223  d7           RST 10H         ; print character (= A register)
        40224  18 f7        JR 247 LBL17
LBL16   40226  3e 20        LD A,32
        40228  d7           RST 10H
        40229  3e 3a        LD A,58
        40231  d7           RST 10H
        40232  21 33 5b     LD HL,23347     ; pointer to current BASIC line-number \
        40235  cd 28 1a     CALL 6696       ; to display after msg
        40238  21 00 03     LD HL,768
        40241  11 64 01     LD DE,356
        40244  cd b5 03     CALL 949        ; emit beep
        40247  c9           RET

; Routine to parse the BIT, RES and SET mnemonics (syntax = BIT <bit>,<register>)
; as input, B must contain the "root" op-code (64 for BIT, 128 for RES, 192 for SET)

        40248  3a 03 5b     LD A,(23299)    ; get bit number
        40251  d6 30        SUB 48          ; note: bit validity is not checked
        40253  fe 0a        CP 10           
        40255  38 05        JR C,5 LBL18
        40257  2e 6e        LD L,110         ; err code = invalid number
        40259  c3 da 5b     JP 23514         ; display error message 
LBL18   40262  a7           AND A           
        40263  17           RLA
        40264  17           RLA
        40265  17           RLA
        40266  80           ADD A,B
        40267  47           LD B,A
        40268  3a 05 5b     LD A,(23301)     ; get register
        40271  4f           LD C,A
        40272  26 00        LD H,0
        40274  11 bc 5b     LD DE,23484      ; search for register in table
LBL20   40277  1a           LD A,(DE)
        40278  b9           CP C
        40279  28 0c        JR Z,12 LBL19
        40281  24           INC H
        40282  13           INC DE
        40283  7c           LD A,H
        40284  fe 09        CP 9
        40286  20 f5        JR NZ,245 LBL20
        40288  2e 9f        LD L,159         ; err code = illegal mnemonic (wrong register) 
        40290  c3 da 5b     JP 23514         ; display error message
LBL19   40293  78           LD A,B
        40294  84           ADD A,H
        40295  4f           LD C,A
        40296  2a 31 5b     LD HL,(23345)    
        40299  36 cb        LD (HL),203      ; write prefix
        40301  23           INC HL
        40302  71           LD (HL),C        ; write op-code of BIT/RES/SET (= C)
        40303  23           INC HL
        40304  22 31 5b     LD (23345),HL
        40307  c3 ce 5b     JP 23502         ; analyze next instruction

; Routine to parse defined label (and to append it to label table) 
; note: instead of the current code address, it is possible to assign a fixed
; value to a label by writing in Mekias assembler:
; *<label>*=<value in decimal>
; label table has the format:

; 1 byte: type (1=defined constant, 2= current address)
; 2 bytes: address (or value) of label
; 1 byte: length of label (=n)
; n bytes: label name

        40310  11 01 5b     LD DE,23297       ; DE <- pointer to 2nd character in instr buffer
        40313  2a 36 5b     LD HL,(23350)     ; 23350 = adress of end of label table
        40316  23           INC HL            ; jump 4 bytes to get to label name field
        40317  23           INC HL
        40318  23           INC HL
        40319  23           INC HL
        40320  06 00        LD B,0            ; B will contain the label-length
LBL22   40322  1a           LD A,(DE)
        40323  fe 2a        CP 42             ; = * (end of label)
        40325  28 0e        JR Z,14 LBL21
        40327  77           LD (HL),A         ; copy label into label table
        40328  23           INC HL
        40329  13           INC DE
        40330  04           INC B
        40331  7b           LD A,E
        40332  fe 0b        CP 11             ; check length
        40334  20 f2        JR NZ,242 LBL22
        40336  2e 7d        LD L,125          ; err code = label too long
        40338  c3 da 5b     JP 23514          ; display error message 
LBL21   40341  2a 36 5b     LD HL,(23350)     ; HL <- adress of end of label table
        40344  23           INC HL
        40345  23           INC HL
        40346  23           INC HL
        40347  70           LD (HL),B         ; store label length
        40348  13           INC DE
        40349  1a           LD A,(DE)
        40350  fe 3d        CP 61             ; = equal sign
        40352  20 14        JR NZ,20 LBL23
        40354  13           INC DE            ; label has to be set with given value
        40355  e5           PUSH HL
        40356  cd cb 5b     CALL 23499        ; convert string to number
        40359  38 06        JR C,6 LBL24
        40361  e1           POP HL
        40362  2e 6e        LD L,110          ; err code = invalid number
        40364  c3 da 5b     JP 23514          ; display error message 
LBL24   40367  54           LD D,H
        40368  5d           LD E,L
        40369  e1           POP HL
        40370  3e 01        LD A,1            ; label type is 1
        40372  18 06        JR 6 LBL25
LBL23   40374  ed 5b 31 5b  LD DE,(23345)     ; label value = PC
        40378  3e 02        LD A,2            ; label type is 2
LBL25   40380  2b           DEC HL
        40381  72           LD (HL),D         ; write value of label
        40382  2b           DEC HL
        40383  73           LD (HL),E
        40384  2b           DEC HL
        40385  77           LD (HL),A         ; write label type
        40386  23           INC HL
        40387  23           INC HL
        40388  23           INC HL
        40389  5e           LD E,(HL)         ; retrieve label length
        40390  16 00        LD D,0
        40392  19           ADD HL,DE ; 
        40393  23           INC HL
        40394  22 36 5b     LD (23350),HL     ; update adress of end of label table
        40397  c3 ce 5b     JP 23502          ; analyze next instruction

; Routine to search for mnemonic corresponding to the one in the line buffer
; actually the mnemo copied to @23312 is spotted. The op-code (if found) is
; written at 23349

        40400  3e 00        LD A,0          ; start at op-code=0 (NOP)
        40402  32 35 5b     LD (23349),A
LBL31   40405  21 10 5b     LD HL,23312     ; clear 15-char buffer @23312
        40408  06 0f        LD B,15
LBL26   40410  36 00        LD (HL),0
        40412  23           INC HL
        40413  10 fb        DJNZ 251 LBL26
        40415  21 10 5b     LD HL,23312      ; copy into buffer @23312 \
LBL28   40418  1a           LD A,(DE)        ; the mnemonic indexed by DE in table until \
        40419  fe 20        CP 32            ; space character read
        40421  28 05        JR Z,5 LBL27
        40423  77           LD (HL),A
        40424  13           INC DE
        40425  23           INC HL
        40426  18 f6        JR 246 LBL28
LBL27   40428  13           INC DE
        40429  d5           PUSH DE
        40430  11 00 5b     LD DE,23296      ; compare line buffer with content \
        40433  21 10 5b     LD HL,23312      ; of buffer @23212
        40436  06 0f        LD B,15
LBL30   40438  1a           LD A,(DE)
        40439  be           CP (HL)          ; compare characters
        40440  20 06        JR NZ,6 LBL29    ; match failed 
        40442  13           INC DE
        40443  23           INC HL
        40444  10 f8        DJNZ 248 LBL30  ; test next character
        40446  d1           POP DE
        40447  c9           RET             ; match => return with DE = address
LBL29   40448  d1           POP DE
        40449  1a           LD A,(DE)
        40450  fe 21        CP 33           ; 33 = ! (marks end of mnemonic table)
        40452  c8           RET Z           ; return (mnemonic not found)
        40453  21 35 5b     LD HL,23349
        40456  34           INC (HL)        ; increase op-code (stored in 23349)
        40457  18 ca        JR 202 LBL31    ; try next mnemonic

; Parse buffer containing Mekias assembler instruction

        40459  3a 00 5b     LD A,(23296)     ; test 1st character in buffer
        40462  fe 7b        CP 123           ; = { (beginning of code= ORG prefix)
        40464  20 1b        JR NZ,27 LBL32
        40466  3e 01        LD A,1
        40468  32 38 5b     LD (23352),A     ; set ORG defined
        40471  11 01 5b     LD DE,23297
        40474  cd cb 5b     CALL 23499       ; parse ORG value (after {)
        40477  38 05        JR C,5 LBL33
        40479  2e 6e        LD L,110         ; err code = invalid value
        40481  c3 da 5b     JP 23514         ; display error message
LBL33   40484  22 31 5b     LD (23345),HL
        40487  22 39 5b     LD (23353),HL
        40490  c3 ce 5b     JP 23502         ; analyze next instruction
LBL32   40493  3a 38 5b     LD A,(23352)     ; check if ORG defined
        40496  fe 00        CP 0
        40498  20 05        JR NZ,5 LBL34
        40500  2e 63        LD L,99          ; err code = ORG not defined
        40502  c3 da 5b     JP 23514         ; display error message
LBL34   40505  3a 00 5b     LD A,(23296)     ; test again 1st char in buffer
        40508  fe 24        CP 36            ; = $
        40510  ca d1 5b     JP Z,23505       ; parse constant string
        40513  fe 23        CP 35            ; = #
        40515  ca d4 5b     JP Z,23508       ; parse constant number (decimal)
        40518  fe 25        CP 37            ;= %
        40520  ca d7 5b     JP Z,23511       ; parse constant number (binary)
        40523  fe 2a        CP 42            ; = *
        40525  ca e0 5b     JP Z,23520 ;     ; parse label
        40528  fe 42        CP 66            ; = B
        40530  20 05        JR NZ,5 LBL35
        40532  06 40        LD B,64
        40534  c3 dd 5b     JP 23517         ; parse BIT mnemo (only one starting with B)
LBL35   40537  fe 52        CP 82            ; = R
        40539  20 13        JR NZ,19 LBL38
        40541  3a 01 5b     LD A,(23297)     ; test 2nd character in line buffer
        40544  fe 45        CP 69            ; = E
        40546  20 0c        JR NZ,12 LBL38
        40548  3a 02 5b     LD A,(23298)     ; test 3rd character in line buffer
        40551  fe 53        CP 83            ; = S
        40553  20 05        JR NZ,5 LBL38
        40555  06 80        LD B,128
        40557  c3 dd 5b     JP 23517         ; parse RES mnemo
LBL38   40560  3a 00 5b     LD A,(23296)
        40563  fe 53        CP 83            ; = S
        40565  20 0c        JR NZ,12 LBL39
        40567  3a 01 5b     LD A,(23297)
        40570  fe 45        CP 69            ; = E
        40572  20 05        JR NZ,5 LBL40
        40574  06 c0        LD B,192
        40576  c3 dd 5b     JP 23517         ; parse SET mnemo (only one starting with SE)
LBL40   40579  3a 00 5b     LD A,(23296)
        40582  fe 3b        CP 59            ; = ;
        40584  ca ce 5b     JP Z,23502       ; line is comment => analyze next instruction
        40587  3a 00 5b     LD A,(23296)
        40590  fe 52        CP 82            ; = R
        40592  20 22        JR NZ,34 LBL42
        40594  3a 01 5b     LD A,(23297)
        40597  fe 53        CP 83            ; = S
        40599  20 1b        JR NZ,27 LBL42
        40601  11 03 5b     LD DE,23299      ; RST instruction found 
        40604  cd cb 5b     CALL 23499       ; convert into number the arg of RST
        40607  38 05        JR C,5 LBL43
        40609  2e 6e        LD L,110         ; err code = invalid number
        40611  c3 da 5b     JP 23514         ; display error message
LBL43   40614  3e c7        LD A,199         ; calculate op-code of RST
        40616  85           ADD A,L          ; L = returned from CALL 23499
        40617  2a 31 5b     LD HL,(23345)    ; write op-code at PC
        40620  77           LD (HL),A
        40621  23           INC HL
        40622  22 31 5b     LD (23345),HL    ; update PC
        40625  c3 ce 5b     JP 23502         ; analyze next instruction
LBL42   40628  3a 00 5b     LD A,(23296)
        40631  fe 4e        CP 78 ; =N
        40633  20 13        JR NZ,19 LBL44
        40635  3a 01 5b     LD A,(23297)
        40638  fe 4f        CP 79 ; =O
        40640  20 0c        JR NZ,12 LBL45
        40642  2a 31 5b     LD HL,(23345)
        40645  36 00        LD (HL),0        ; store NOP op-code and update PC
        40647  23           INC HL
        40648  22 31 5b     LD (23345),HL
        40651  c3 ce 5b     JP 23502         ; analyze next instruction
LBL45   40654  11 00 5b     LD DE,23296      ; extract mnemonic and label...
        40657  01 20 5b     LD BC,23328      ; BC <- pointer to buffer for label 
        40660  21 00 5b     LD HL,23296
LBL51   40663  1a           LD A,(DE)        ; beginning of loop to scan buffer char-by-char
        40664  fe 2a        CP 42            ; = * (label marker)    
        40666  20 0e        JR NZ,14 LBL46
        40668  13           INC DE
        40669  3a 3c 5b     LD A,(23356)     ; invert @23356
        40672  ee ff        XOR 255          ; (toggle "used-label being read" flag)
        40674  32 3c 5b     LD (23356),A
        40677  3e 01        LD A,1
        40679  32 3b 5b     LD (23355),A     ; type of argument = 1 (used-label)
LBL46   40682  3a 3c 5b     LD A,(23356)
        40685  fe 00        CP 0
        40687  28 0e        JR Z,14 LBL47
        40689  1a           LD A,(DE)        ; if @23256 = 1, label is being read
        40690  02           LD (BC),A        ; (store label at 23328)
        40691  13           INC DE
        40692  03           INC BC
        40693  79           LD A,C
        40694  fe 27        CP 39            ; BC = 23335 => end of label buffer reached
        40696  20 dd        JR NZ,221 LBL51
        40698  2e 7d        LD L,125         ; code err = label too long
        40700  c3 da 5b     JP 23514         ; display error message
LBL47   40703  1a           LD A,(DE)
        40704  d6 30        SUB 48
        40706  fe 0a        CP 10
        40708  30 16        JR NC,22 LBL49   ; jump if character read is not a digit 
        40710  e5           PUSH HL
        40711  d5           PUSH DE
        40712  cd cb 5b     CALL 23499       ; convert the string of digits to number
        40715  d1           POP DE
        40716  22 20 5b     LD (23328),HL    ; store argument of op-code
        40719  e1           POP HL
        40720  3e 02        LD A,2
        40722  32 3b 5b     LD (23355),A     ; type of argument = 2 (number)
        40725  3a 30 5b     LD A,(23344)     ; get number of digits in number
        40728  83           ADD A,E          ; update pointer of buffer accordingly
        40729  5f           LD E,A
        40730  18 04        JR 4 LBL50
LBL49   40732  1a           LD A,(DE)       ; copy chars of mnemonic in buffer \
        40733  77           LD (HL),A       ; (numbers and labels stripped) \
        40734  23           INC HL          ; note: this probably requires to have \
        40735  13           INC DE          ; an instruction-length much less than \
LBL50   40736  7b           LD A,E          ; 32 characters (24 ?) to have padding zeros \
        40737  fe 20        CP 32           ; on right side shifted to the left...
        40739  20 b2        JR NZ,178 LBL51 ; go to next char in instruction buffer
        40741  11 58 a2     LD DE,41560     ; beginning of mnemonic table
        40744  cd e3 5b     CALL 23523      ; search for mnemonic
        40747  1a           LD A,(DE)
        40748  fe 21        CP 33           ; =! (end of mnemonic table reached)
        40750  20 0e        JR NZ,14 LBL52
        40752  13           INC DE
        40753  cd e3 5b     CALL 23523      ; search for mnemomic in 2nd table \
        40756  1a           LD A,(DE)       ; (op-codes with CB or ED prefixes)
        40757  fe 21        CP 33           ; =! (end of mnemonic table reached)
        40759  20 2e        JR NZ,46 LBL53
        40761  2e 9f        LD L,159        ; "unknown mnemonic" error code
        40763  c3 da 5b     JP 23514        ; display error message
LBL52   40766  3a 35 5b     LD A,(23349)    ; get op-code found
        40769  2a 31 5b     LD HL,(23345)   ; store op-code at PC
        40772  77           LD (HL),A
        40773  23           INC HL
        40774  22 31 5b     LD (23345),HL   ; update PC
        40777  21 4a 5b     LD HL,23370     ; HL <- table of op-codes with 1-byte arg
        40780  06 19        LD B,25         ; B <-  table size (25 elements)
LBL55   40782  be           CP (HL)
        40783  28 05        JR Z,5 LBL54
        40785  23           INC HL
        40786  10 fa        DJNZ 250 LBL55
        40788  18 2d        JR 45 LBL56
LBL54   40790  3a 35 5b     LD A,(23349)     ; check if 3 last bits of op-code are 0 \
        40793  e6 07        AND 7            ; => correspond to JR*, DJNZ \
        40795  20 05        JR NZ,5 LBL57    
        40797  01 01 04     LD BC,1025       ; B <- label-type = 4 (relative jump) \ 
        40800  18 03        JR 3 LBL58       ; C <- size = 1 byte
LBL57   40802  01 01 05     LD BC,1281       ; B <- label-type = 5 (1-byte arg) \
LBL58   40805  18 1f        JR 31 LBL59      ; C <- size = 1 byte
LBL53   40807  2a 31 5b     LD HL,(23345)    ; op-code found has CB or ED prefix
        40810  3a 35 5b     LD A,(23349)
        40813  fe 3f        CP 63            ; op-code with CB prefixes are < 64 \
        40815  38 0a        JR C,10 LBL60    ; (BIT, RES, SET are processed separately)
        40817  36 ed        LD (HL),237      ; write ED prefix
        40819  fe 7c        CP 124
        40821  38 02        JR C,2 LBL61
        40823  c6 23        ADD A,35         ; adjust op-code value (gap in table ?)
LBL61   40825  18 02        JR 2 LBL62
LBL60   40827  36 cb        LD (HL),203      ; write CB prefix
LBL62   40829  23           INC HL
        40830  77           LD (HL),A        ; write op-code at PC
        40831  23           INC HL
        40832  22 31 5b     LD (23345),HL    ; update PC
LBL56   40835  01 02 03     LD BC,770        ; B <- label-type = 3 (2-byte arg)
LBL59   40838  3a 3b 5b     LD A,(23355)     ; check type of argument
        40841  fe 00        CP 0
        40843  ca ce 5b     JP Z,23502       ; if = 0 => no arg, analyze next instruction
        40846  fe 01        CP 1
        40848  28 28        JR Z,40 LBL63    ; if = 1 => arg is label
        40850  2a 31 5b     LD HL,(23345)    ; argument is number
        40853  3a 20 5b     LD A,(23328)     ; get LS of value of argument
        40856  77           LD (HL),A        ; write it at PC
        40857  23           INC HL
        40858  22 31 5b     LD (23345),HL    ; update PC
        40861  79           LD A,C           
        40862  fe 01        CP 1             ; check size of argument 
        40864  20 0d        JR NZ,13 LBL64
        40866  3a 21 5b     LD A,(23329)     ; check MS is 0 (arg value < 256)
        40869  fe 00        CP 0
        40871  ca ce 5b     JP Z,23502       ; analyze next instruction
        40874  2e 6e        LD L,110         ; err code = invalid number (too bug for 1 byte)
        40876  c3 da 5b     JP 23514         ; display error message
LBL64   40879  3a 21 5b     LD A,(23329)     ; get MS of value of argument 
        40882  77           LD (HL),A        ; write it at PC
        40883  23           INC HL
        40884  22 31 5b     LD (23345),HL    ; update PC
        40887  c3 ce 5b     JP 23502         ; analyze next instruction
LBL63   40890  2a 36 5b     LD HL,(23350)    ; HL <- pointer to end of label table
        40893  70           LD (HL),B        ; create new label entry, write label type
        40894  23           INC HL
        40895  3a 31 5b     LD A,(23345)     ; write address of used-label = PC
        40898  77           LD (HL),A
        40899  23           INC HL
        40900  3a 32 5b     LD A,(23346)
        40903  77           LD (HL),A
        40904  23           INC HL
        40905  22 3d 5b     LD (23357),HL    ; save label-length field address
        40908  23           INC HL
        40909  06 00        LD B,0
        40911  11 20 5b     LD DE,23328
LBL66   40914  1a           LD A,(DE)        ; copy name of used-label  into table \
        40915  fe 00        CP 0             ; until null charcter found
        40917  28 06        JR Z,6 LBL65
        40919  77           LD (HL),A
        40920  13           INC DE
        40921  23           INC HL
        40922  04           INC B           ; B = label-length
        40923  18 f5        JR 245 LBL66
LBL65   40925  22 36 5b     LD (23350),HL   ; update pointer to end of label table
        40928  2a 3d 5b     LD HL,(23357)   ; write label-length into field of table
        40931  70           LD (HL),B
        40932  2a 31 5b     LD HL,(23345)   
        40935  23           INC HL          ; increment PC
        40936  79           LD A,C          ; check size of argument (= C)
        40937  fe 01        CP 1
        40939  28 01        JR Z,1 LBL67
        40941  23           INC HL          ; increment PC again if size is 2
LBL67   40942  22 31 5b     LD (23345),HL
        40945  c3 ce 5b     JP 23502        ; analyze next instruction

; Routine to resolve the labels

        40948  2a 3f 5b     LD HL,(23359) ; HL <- start of label table
        40951  ed 4b 36 5b  LD BC,(23350) ; BC <- end of label table
        40955  16 00        LD D,0
LBL72   40957  7e           LD A,(HL)     ; get type of label
        40958  fe 01        CP 1
        40960  28 06        JR Z,6 LBL69
        40962  fe 02        CP 2
        40964  28 02        JR Z,2 LBL69
        40966  18 0f        JR 15 LBL70  ; if label is "used" (type not 1 and not 2), resolve it
LBL69   40968  23           INC HL       ; go to next label in table (re-iteration after \
        40969  23           INC HL       ; label resolution starts here, not from LBL72 !)
        40970  23           INC HL
        40971  5e           LD E,(HL)       ; get label length
        40972  19           ADD HL,DE       ; point to next label
        40973  23           INC HL
        40974  7c           LD A,H          ; check if end of table reached (BC=HL)
        40975  b8           CP B
        40976  20 eb        JR NZ,235 LBL72 ; look at next label
        40978  7d           LD A,L
        40979  b9           CP C
        40980  20 e7        JR NZ,231 LBL72
        40982  c9           RET
LBL70   40983  22 41 5b     LD (23361),HL   ; save address-in-table of used-label to resolve
        40986  23           INC HL
        40987  23           INC HL
        40988  23           INC HL
        40989  7e           LD A,(HL)
        40990  32 43 5b     LD (23363),A  ; save used-label length (useless ?)
        40993  2a 3f 5b     LD HL,(23359) ; HL <- start of table
LBL79   40996  ed 4b 36 5b  LD BC,(23350) ; scan label...
        41000  7e           LD A,(HL)
        41001  fe 01        CP 1
        41003  28 04        JR Z,4 LBL73
        41005  fe 02        CP 2
        41007  20 1c        JR NZ,28 LBL74
LBL73   41009  22 44 5b     LD (23364),HL  ; scanned label is a defined label, \
        41012  23           INC HL         ; save its address-in-table
        41013  23           INC HL
        41014  23           INC HL
        41015  ed 5b 41 5b  LD DE,(23361)  ; DE <- address-in-table of used-label to resolve
        41019  13           INC DE
        41020  13           INC DE
        41021  13           INC DE
        41022  46           LD B,(HL)      ; B <- scanned (=defined) label length
        41023  04           INC B
LBL76   41024  1a           LD A,(DE)      ; check if used label = scanned label
        41025  be           CP (HL)        ; (compare character-by-character)
        41026  20 06        JR NZ,6 LBL75  ; note: this may lead to wrong resolutioh if \
        41028  13           INC DE         ; used label = XXXYYY and defined label = XXX
        41029  23           INC HL
        41030  10 f8        DJNZ 248 LBL76
        41032  18 18        JR 24 LBL77
LBL75   41034  2a 44 5b     LD HL,(23364)   ; prepare to scan next label...
LBL74   41037  23           INC HL           
        41038  23           INC HL
        41039  23           INC HL
        41040  16 00        LD D,0
        41042  5e           LD E,(HL)        ; get current label length
        41043  19           ADD HL,DE        ; HL <- position of next label in table
        41044  23           INC HL
        41045  7c           LD A,H           ; check if HL=BC (end of table reached)
        41046  b8           CP B             ; problem: B has been modified at 41022 !?!? 
        41047  20 cb        JR NZ,203 LBL79  ;
        41049  7d           LD A,L
        41050  b9           CP C
        41051  20 c7        JR NZ,199 LBL79
        41053  2e ad        LD L,173         ; err code = unknown label
        41055  c3 da 5b     JP 23514         ; display error message
LBL77   41058  ed 5b 44 5b  LD DE,(23364)    ; label is resolved !
        41062  2a 41 5b     LD HL,(23361)    ; HL <- address-in-table of used-label
        41065  7e           LD A,(HL)
        41066  fe 03        CP 3
        41068  28 22        JR Z,34 LBL80    ; used-label is for 2-byte arg / abs jump (type 3)
        41070  fe 04        CP 4
        41072  28 35        JR Z,53 LBL81    ; used-label is for relative jump (type 4)
        41074  23           INC HL           ; used-label is for 1-byte arg (type 5)
        41075  4e           LD C,(HL)        ; get address related to used-label 
        41076  23           INC HL
        41077  46           LD B,(HL)
        41078  13           INC DE
        41079  1a           LD A,(DE)
        41080  02           LD (BC),A        ; write LS of defined-label value
        41081  13           INC DE
        41082  1a           LD A,(DE)
        41083  fe 00        CP 0             ; if defined-label value > 255 => error
        41085  28 05        JR Z,5 LBL82
        41087  2e 6e        LD L,110         ; err code = invalid number
        41089  c3 da 5b     JP 23514         ; display error message
LBL82   41092  2a 41 5b     LD HL,(23361)    ; resolved label will be skipped after JP 23532
        41095  ed 4b 36 5b  LD BC,(23350)    ; BC <- address of table end
        41099  16 00        LD D,0
        41101  c3 ec 5b     JP 23532      ; = eq. LBL69 (jump-back too big to be relative ?)
LBL80   41104  23           INC HL        ; get address related to used-label 
        41105  4e           LD C,(HL)
        41106  23           INC HL
        41107  46           LD B,(HL)     ; BC <- address of used label
        41108  13           INC DE        ; DE <- value of defined label
        41109  1a           LD A,(DE)  
        41110  02           LD (BC),A     ; write argument (LS)
        41111  13           INC DE
        41112  03           INC BC
        41113  1a           LD A,(DE)
        41114  02           LD (BC),A     ; write argument (MS)
        41115  2a 41 5b     LD HL,(23361) ; resolved label will be skipped after JP 23532
        41118  ed 4b 36 5b  LD BC,(23350) ; BC <- address of table end
        41122  16 00        LD D,0
        41124  c3 ec 5b     JP 23532      ; = eq. LBL69 (jump-back too big to be relative ?)
LBL81   41127  23           INC HL
        41128  4e           LD C,(HL)
        41129  23           INC HL
        41130  46           LD B,(HL)     ; BC <- address of used label
        41131  13           INC DE        ; DE <- value of defined label
        41132  1a           LD A,(DE)
        41133  6f           LD L,A
        41134  13           INC DE
        41135  1a           LD A,(DE)
        41136  67           LD H,A
        41137  a7           AND A         ; clear carry flag
        41138  ed 42        SBC HL,BC     ; calculate relative jump
        41140  2b           DEC HL
        41141  7d           LD A,L
        41142  02           LD (BC),A     ; write value of relative jump
        41143  2a 41 5b     LD HL,(23361) ; resolved label will be skipped after JP 23532
        41146  ed 4b 36 5b  LD BC,(23350) ; BC <- address of table end
        41150  16 00        LD D,0
        41152  c3 ec 5b     JP 23532      ; = eq. LBL69 (jump-back too big to be relative ?)
        
; START OF COMPILATION (triggered by RUN in command line)

        41155  01 ff 00     LD BC,255       ; variable initialization
        41158  11 00 5b     LD DE,23296   
        41161  21 54 a1     LD HL,41300     ; initial values are located at 41300
        41164  ed b0        LDIR            ; copy block of values

; search for lines starting with a REM 

LBL87   41166  2a 46 5b     LD HL,(23366)   ; 23366=pointer on BASIC line to read
        41169  7e           LD A,(HL)
        41170  32 33 5b     LD (23347),A    ; store LS byte of BASIC line number
        41173  23           INC HL
        41174  7e           LD A,(HL)
        41175  32 34 5b     LD (23348),A    ; store MS byte of BASIC line number
        41178  23           INC HL
        41179  5e           LD E,(HL)       ; get BASIC line length
        41180  23           INC HL
        41181  56           LD D,(HL)
        41182  23           INC HL
        41183  e5           PUSH HL
        41184  19           ADD HL,DE
        41185  22 46 5b     LD (23366),HL   ; update pointer on BASIC line to read
        41188  e1           POP HL
        41189  7e           LD A,(HL)       ; get BASIC instruction
        41190  fe ea        CP 234          ; = REM
        41192  20 e4        JR NZ,228 LBL87 ; go to next BASIC line
        41194  23           INC HL
LBL88   41195  11 00 5b     LD DE,23296     ; buffer to where the line will be \
LBL91   41198  7e           LD A,(HL)       ; copied (space chars omitted)
        41199  fe 27        CP 39           ; = ' (instruction separator) \
        41201  28 04        JR Z,4 LBL84    ; => parse buffer immedialtely
        41203  fe 0d        CP 13           ; = ENTER (end of line)
        41205  20 1f        JR NZ,31 LBL85
LBL84   41207  22 44 5b     LD (23364),HL   ; save pointer on BASIC code
        41210  c3 e6 5b     JP 23526        ; parse instruction buffer

; Analysis of instruction in REM starts here
; (after an instruction is processed, program jumps here)

        41213  06 2f        LD B,47       ; clear buffers (length=47 chars)...
        41215  3e 00        LD A,0
        41217  32 3b 5b     LD (23355),A  ; type of op-code argument is 0 (no arg) by default
        41220  11 00 5b     LD DE,23296
LBL86   41223  12           LD (DE),A
        41224  13           INC DE
        41225  10 fc        DJNZ 252 LBL86
        41227  2a 44 5b     LD HL,(23364)  ; buffers now cleared, get pointer on BASIC code
        41230  7e           LD A,(HL)
        41231  fe 0d        CP 13          ; = ENTER (end of line)
        41233  28 bb        JR Z,187 LBL87 ; => process next BASIC line
        41235  23           INC HL         ; likely another instruction in same line \
        41236  18 d5        JR 213 LBL88   ; (' separator), analyze it

LBL85   41238  fe 20        CP 32          ; = space character (omit)
        41240  28 06        JR Z,6 LBL89
        41242  fe 7d        CP 125         ; = } (marks end of Mekias assembly code)
        41244  28 0d        JR Z,13 LBL90
        41246  12           LD (DE),A      ; copy line of BASIC into buffer
        41247  13           INC DE
LBL89   41248  23           INC HL
        41249  7b           LD A,E
        41250  fe 20        CP 32           ; max = 32 char (too big ?)
        41252  20 c8        JR NZ,200 LBL91
        41254  2e 8d        LD L,141        ; err code = line too long
        41256  c3 da 5b     JP 23514        ; display error message

; End-of-compilation routines

LBL90   41259  2a 3f 5b     LD HL,(23359)   ; = start of label table
        41262  ed 5b 36 5b  LD DE,(23350)   ; = end of label table
        41266  7c           LD A,H
        41267  ba           CP D
        41268  20 04        JR NZ,4 LBL92 ; 
        41270  7d           LD A,L
        41271  bb           CP E
        41272  28 03        JR Z,3 LBL93
LBL92   41274  cd e9 5b     CALL 23529      ; if (DE)!=(HL), resolve labels
LBL93   41277  00           NOP             ; zone reserved for future use ?
        41278  00           NOP
        41279  00           NOP
        41280  00           NOP
        41281  00           NOP
        41282  00           NOP
        41283  00           NOP
        41284  00           NOP
        41285  00           NOP
        41286  00           NOP
        41287  00           NOP
        41288  21 00 03     LD HL,768        ; emit beep
        41291  11 64 00     LD DE,100
        41294  cd b5 03     CALL 949
        41297  c9           RET              ; end of compilation

; Block containing:
; - Initial variable values.
; - Op-codes having one-byte arguments.
; - Error messages.
; - Z80 register names.
; - Table of absolute jumps.
; (block copied to address 23296 at initialization)
; What follows is an hexdump of Mekias_as_installed.sna. I have
; removed the addresses (and just indicated the start address in decimal)
; Noticeable initial values:
; - Pointers to label table: xAB54 = 43860. Value to be used by vars at 23350 and 23359.
; - Beginning of BASIC code: x5CCB = 23755. Value assumed to be constant
;   (normally it is the value of sys-var at 23635), to be used by var at 23364.

41300  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
       00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
       00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
       00 00 00 64 00 54 ab 00  00 00 00 00 00 00 54 ab  |...d.T........T.|
       00 00 00 00 00 cb 5c 00  00 06 0e 16 1e 26 2e 36  |......\......&.6|
       3e c6 ce d6 de e6 ee f6  fe d3 db 10 18 20 28 30  |>............ (0|
       38 1a 00 4f 52 47 20 61  62 73 65 6e 74 0d 4e 6f  |8..ORG absent.No|
       6d 62 72 65 20 69 6c 6c  65 67 61 6c 0d 4c 61 62  |mbre illegal.Lab|
       65 6c 20 74 72 6f 70 20  6c 6f 6e 67 0d 4c 69 67  |el trop long.Lig|      
       6e 65 20 74 72 6f 70 20  6c 6f 6e 67 75 65 0d 4d  |ne trop longue.M|   
       6e 65 6d 6f 20 69 6e 63  6f 6e 6e 75 0d 4c 61 62  |nemo inconnu.Lab|
       65 6c 20 69 6e 63 6f 6e  6e 75 0d 42 43 44 45 48  |el inconnu.BCDEH|
       4c 28 41 21 00 00 00 c3  40 9c c3 4b 9c c3 fd a0  |L(A!....@..K....|
       c3 97 9c c3 b1 9c c3 d5  9c c3 0d 9d c3 38 9d c3  |.............8..|
       76 9d c3 d0 9d c3 0b 9e  c3 f4 9f c3 08 a0 00 00  |v...............|
       00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
       
; Mnemonic tables (1st table = no prefix starts at 41560)
; Mnemonics are separated by space characters.
; Tables are separated by ! characters.
; 1st table = no prefix
; 2nd table = CB and ED prefixes

41556  00 00 00 4e 4f 50 20 4c  44 42 43 2c 20 4c 44 28  |...NOP LDBC, LD(|
       42 43 29 2c 41 20 49 4e  43 42 43 20 49 4e 43 42  |BC),A INCBC INCB|
       20 44 45 43 42 20 4c 44  42 2c 20 52 4c 43 41 20  | DECB LDB, RLCA |
       45 58 41 46 41 46 20 41  44 44 48 4c 2c 42 43 20  |EXAFAF ADDHL,BC |
       4c 44 41 2c 28 42 43 29  20 44 45 43 42 43 20 49  |LDA,(BC) DECBC I|
       4e 43 43 20 44 45 43 43  20 4c 44 43 2c 20 52 52  |NCC DECC LDC, RR|
       43 41 20 44 4a 4e 5a 20  4c 44 44 45 2c 20 4c 44  |CA DJNZ LDDE, LD|
       28 44 45 29 2c 41 20 49  4e 43 44 45 20 49 4e 43  |(DE),A INCDE INC|
       44 20 44 45 43 44 20 4c  44 44 2c 20 52 4c 41 20  |D DECD LDD, RLA |
       4a 52 20 41 44 44 48 4c  2c 44 45 20 4c 44 41 2c  |JR ADDHL,DE LDA,|
       28 44 45 29 20 44 45 43  44 45 20 49 4e 43 45 20  |(DE) DECDE INCE |
       44 45 43 45 20 4c 44 45  2c 20 52 52 41 20 4a 52  |DECE LDE, RRA JR|
       4e 5a 20 4c 44 48 4c 2c  20 4c 44 28 29 2c 48 4c  |NZ LDHL, LD(),HL|
       20 49 4e 43 48 4c 20 49  4e 43 48 20 44 45 43 48  | INCHL INCH DECH|
       20 4c 44 48 2c 20 44 41  41 20 4a 52 5a 20 41 44  | LDH, DAA JRZ AD|
       44 48 4c 2c 48 4c 20 4c  44 48 4c 2c 28 29 20 44  |DHL,HL LDHL,() D|
       45 43 48 4c 20 49 4e 43  4c 20 44 45 43 4c 20 4c  |ECHL INCL DECL L|
       44 4c 2c 20 43 50 2d 4c  20 4a 52 4e 43 20 4c 44  |DL, CP-L JRNC LD|
       53 50 2c 20 4c 44 28 29  2c 41 20 49 4e 43 53 50  |SP, LD(),A INCSP|
       20 49 4e 43 28 48 4c 29  20 44 45 43 28 48 4c 29  | INC(HL) DEC(HL)|
       20 4c 44 28 48 4c 29 2c  20 53 43 46 20 4a 52 43  | LD(HL), SCF JRC|
       20 41 44 44 48 4c 2c 53  50 20 4c 44 41 2c 28 29  | ADDHL,SP LDA,()|
       20 44 45 43 53 50 20 49  4e 43 41 20 44 45 43 41  | DECSP INCA DECA|
       20 4c 44 41 2c 20 43 43  46 20 4c 44 42 2c 42 20  | LDA, CCF LDB,B |
       4c 44 42 2c 43 20 4c 44  42 2c 44 20 4c 44 42 2c  |LDB,C LDB,D LDB,|
       45 20 4c 44 42 2c 48 20  4c 44 42 2c 4c 20 4c 44  |E LDB,H LDB,L LD|
       42 2c 28 48 4c 29 20 4c  44 42 2c 41 20 4c 44 43  |B,(HL) LDB,A LDC|
       2c 42 20 4c 44 43 2c 43  20 4c 44 43 2c 44 20 4c  |,B LDC,C LDC,D L|
       44 43 2c 45 20 4c 44 43  2c 48 20 4c 44 43 2c 4c  |DC,E LDC,H LDC,L|
       20 4c 44 43 2c 28 48 4c  29 20 4c 44 43 2c 41 20  | LDC,(HL) LDC,A |
       4c 44 44 2c 42 20 4c 44  44 2c 43 20 4c 44 44 2c  |LDD,B LDD,C LDD,|
       44 20 4c 44 44 2c 45 20  4c 44 44 2c 48 20 4c 44  |D LDD,E LDD,H LD|
       44 2c 4c 20 4c 44 44 2c  28 48 4c 29 20 4c 44 44  |D,L LDD,(HL) LDD|
       2c 41 20 4c 44 45 2c 42  20 4c 44 45 2c 43 20 4c  |,A LDE,B LDE,C L|
       44 45 2c 44 20 4c 44 45  2c 45 20 4c 44 45 2c 48  |DE,D LDE,E LDE,H|
       20 4c 44 45 2c 4c 20 4c  44 45 2c 28 48 4c 29 20  | LDE,L LDE,(HL) |
       4c 44 45 2c 41 20 4c 44  48 2c 42 20 4c 44 48 2c  |LDE,A LDH,B LDH,|
       43 20 4c 44 48 2c 44 20  4c 44 48 2c 45 20 4c 44  |C LDH,D LDH,E LD|
       48 2c 48 20 4c 44 48 2c  4c 20 4c 44 48 2c 28 48  |H,H LDH,L LDH,(H|
       4c 29 20 4c 44 48 2c 41  20 4c 44 4c 2c 42 20 4c  |L) LDH,A LDL,B L|
       44 4c 2c 43 20 4c 44 4c  2c 44 20 4c 44 4c 2c 45  |DL,C LDL,D LDL,E|
       20 4c 44 4c 2c 48 20 4c  44 4c 2c 4c 20 4c 44 4c  | LDL,H LDL,L LDL|
       2c 28 48 4c 29 20 4c 44  4c 2c 41 20 4c 44 28 48  |,(HL) LDL,A LD(H|
       4c 29 2c 42 20 4c 44 28  48 4c 29 2c 43 20 4c 44  |L),B LD(HL),C LD|
       28 48 4c 29 2c 44 20 4c  44 28 48 4c 29 2c 45 20  |(HL),D LD(HL),E |
       4c 44 28 48 4c 29 2c 48  20 4c 44 28 48 4c 29 2c  |LD(HL),H LD(HL),|
       4c 20 48 41 4c 54 20 4c  44 28 48 4c 29 2c 41 20  |L HALT LD(HL),A |
       4c 44 41 2c 42 20 4c 44  41 2c 43 20 4c 44 41 2c  |LDA,B LDA,C LDA,|
       44 20 4c 44 41 2c 45 20  4c 44 41 2c 48 20 4c 44  |D LDA,E LDA,H LD|
       41 2c 4c 20 4c 44 41 2c  28 48 4c 29 20 4c 44 41  |A,L LDA,(HL) LDA|
       2c 41 20 41 44 44 41 2c  42 20 41 44 44 41 2c 43  |,A ADDA,B ADDA,C|
       20 41 44 44 41 2c 44 20  41 44 44 41 2c 45 20 41  | ADDA,D ADDA,E A|
       44 44 41 2c 48 20 41 44  44 41 2c 4c 20 41 44 44  |DDA,H ADDA,L ADD|
       41 2c 28 48 4c 29 20 41  44 44 41 2c 41 20 41 44  |A,(HL) ADDA,A AD|
       43 41 2c 42 20 41 44 43  41 2c 43 20 41 44 43 41  |CA,B ADCA,C ADCA|
       2c 44 20 41 44 43 41 2c  45 20 41 44 43 41 2c 48  |,D ADCA,E ADCA,H|
       20 41 44 43 41 2c 4c 20  41 44 43 41 2c 28 48 4c  | ADCA,L ADCA,(HL|
       29 20 41 44 43 41 2c 41  20 53 55 42 42 20 53 55  |) ADCA,A SUBB SU|
       42 43 20 53 55 42 44 20  53 55 42 45 20 53 55 42  |BC SUBD SUBE SUB|
       48 20 53 55 42 4c 20 53  55 42 28 48 4c 29 20 53  |H SUBL SUB(HL) S|
       55 42 41 20 53 42 43 41  2c 42 20 53 42 43 41 2c  |UBA SBCA,B SBCA,|
       43 20 53 42 43 41 2c 44  20 53 42 43 41 2c 45 20  |C SBCA,D SBCA,E |
       53 42 43 41 2c 48 20 53  42 43 41 2c 4c 20 53 42  |SBCA,H SBCA,L SB|
       43 41 2c 28 48 4c 29 20  53 42 43 41 2c 41 20 41  |CA,(HL) SBCA,A A|
       4e 44 42 20 41 4e 44 43  20 41 4e 44 44 20 41 4e  |NDB ANDC ANDD AN|
       44 45 20 41 4e 44 48 20  41 4e 44 4c 20 41 4e 44  |DE ANDH ANDL AND|
       28 48 4c 29 20 41 4e 44  41 20 58 4f 52 42 20 58  |(HL) ANDA XORB X|
       4f 52 43 20 58 4f 52 44  20 58 4f 52 45 20 58 4f  |ORC XORD XORE XO|
       52 48 20 58 4f 52 4c 20  58 4f 52 28 48 4c 29 20  |RH XORL XOR(HL) |
       58 4f 52 41 20 4f 52 42  20 4f 52 43 20 4f 52 44  |XORA ORB ORC ORD|
       20 4f 52 45 20 4f 52 48  20 4f 52 4c 20 4f 52 28  | ORE ORH ORL OR(|
       48 4c 29 20 4f 52 41 20  43 50 42 20 43 50 43 20  |HL) ORA CPB CPC |
       43 50 44 20 43 50 45 20  43 50 48 20 43 50 4c 20  |CPD CPE CPH CPL |
       43 50 28 48 4c 29 20 43  50 41 20 52 45 54 4e 5a  |CP(HL) CPA RETNZ|
       20 50 4f 50 42 43 20 4a  50 4e 5a 20 4a 50 20 43  | POPBC JPNZ JP C|
       41 4c 4c 4e 5a 20 50 55  53 48 42 43 20 41 44 44  |ALLNZ PUSHBC ADD|
       41 2c 20 52 53 54 30 20  52 45 54 5a 20 52 45 54  |A, RST0 RETZ RET|
       20 4a 50 5a 20 5f 20 43  41 4c 4c 5a 20 43 41 4c  | JPZ _ CALLZ CAL|
       4c 20 41 44 43 41 2c 20  52 53 54 38 20 52 45 54  |L ADCA, RST8 RET|
       4e 43 20 50 4f 50 44 45  20 4a 50 4e 43 20 4f 55  |NC POPDE JPNC OU|
       54 28 29 2c 41 20 43 41  4c 4c 4e 43 20 50 55 53  |T(),A CALLNC PUS|
       48 44 45 20 53 55 42 20  52 53 54 31 36 20 52 45  |HDE SUB RST16 RE|
       54 43 20 45 58 58 20 4a  50 43 20 49 4e 41 2c 28  |TC EXX JPC INA,(|
       29 20 43 41 4c 4c 43 20  49 58 49 20 53 42 43 41  |) CALLC IXI SBCA|
       2c 20 52 53 54 32 34 20  52 45 54 50 4f 20 50 4f  |, RST24 RETPO PO|
       50 48 4c 20 4a 50 50 4f  20 45 58 28 53 50 29 2c  |PHL JPPO EX(SP),|
       48 4c 20 43 41 4c 4c 50  4f 20 50 55 53 48 48 4c  |HL CALLPO PUSHHL|
       20 41 4e 44 20 52 53 54  33 32 20 52 45 54 50 45  | AND RST32 RETPE|
       20 4a 50 28 48 4c 29 20  4a 50 50 45 20 45 58 44  | JP(HL) JPPE EXD|
       45 2c 48 4c 20 43 41 4c  4c 50 45 20 5f 20 58 4f  |E,HL CALLPE _ XO|
       52 20 52 53 54 34 30 20  52 45 54 50 20 50 4f 50  |R RST40 RETP POP|
       41 46 20 4a 50 50 20 44  49 20 43 41 4c 4c 50 20  |AF JPP DI CALLP |
       50 55 53 48 41 46 20 4f  52 20 52 53 54 34 38 20  |PUSHAF OR RST48 |
       52 45 54 4d 20 4c 44 53  50 2c 48 4c 20 4a 50 4d  |RETM LDSP,HL JPM|
       20 45 49 20 43 41 4c 4c  4d 20 49 59 49 20 43 50  | EI CALLM IYI CP|
       20 52 53 54 35 36 20 21  52 4c 43 42 20 52 4c 43  | RST56 !RLCB RLC|
       43 20 52 4c 43 44 20 52  4c 43 45 20 52 4c 43 48  |C RLCD RLCE RLCH|
       20 52 4c 43 4c 20 52 4c  43 28 48 4c 29 20 52 4c  | RLCL RLC(HL) RL|
       43 41 20 52 52 43 42 20  52 52 43 43 20 52 52 43  |CA RRCB RRCC RRC|
       44 20 52 52 43 45 20 52  52 43 48 20 52 52 43 4c  |D RRCE RRCH RRCL|
       20 52 52 43 28 48 4c 29  20 52 52 43 41 20 52 4c  | RRC(HL) RRCA RL|
       42 20 52 4c 43 20 52 4c  44 20 52 4c 45 20 52 4c  |B RLC RLD RLE RL|
       48 20 52 4c 4c 20 52 4c  28 48 4c 29 20 52 4c 41  |H RLL RL(HL) RLA|
       20 52 52 42 20 52 52 43  20 52 52 44 20 52 52 45  | RRB RRC RRD RRE|
       20 52 52 48 20 52 52 4c  20 52 52 28 48 4c 29 20  | RRH RRL RR(HL) |
       52 52 41 20 53 4c 41 42  20 53 4c 41 43 20 53 4c  |RRA SLAB SLAC SL|
       41 44 20 53 4c 41 45 20  53 4c 41 48 20 53 4c 41  |AD SLAE SLAH SLA|
       4c 20 53 4c 41 28 48 4c  29 20 53 4c 41 41 20 53  |L SLA(HL) SLAA S|
       52 41 42 20 53 52 41 43  20 53 52 41 44 20 53 52  |RAB SRAC SRAD SR|
       41 45 20 53 52 41 48 20  53 52 41 4c 20 53 52 41  |AE SRAH SRAL SRA|
       28 48 4c 29 20 53 52 41  41 20 26 42 20 26 43 20  |(HL) SRAA &B &C |
       26 44 20 26 45 20 26 48  20 26 4c 20 26 28 48 4c  |&D &E &H &L &(HL|
       29 20 26 41 20 53 52 4c  42 20 53 52 4c 43 20 53  |) &A SRLB SRLC S|
       52 4c 44 20 53 52 4c 45  20 53 52 4c 48 20 53 52  |RLD SRLE SRLH SR|
       4c 4c 20 53 52 4c 28 48  4c 29 20 53 52 4c 41 20  |LL SRL(HL) SRLA |
       49 4e 42 2c 28 43 29 20  4f 55 54 28 43 29 2c 42  |INB,(C) OUT(C),B|
       20 53 42 43 48 4c 2c 42  43 20 4c 44 28 29 2c 42  | SBCHL,BC LD(),B|
       43 20 4e 45 47 20 52 45  54 4e 20 49 4d 5a 20 4c  |C NEG RETN IMZ L|
       44 49 2c 41 20 49 4e 43  2c 28 43 29 20 4f 55 54  |DI,A INC,(C) OUT|
       28 43 29 2c 43 20 41 44  43 48 4c 2c 42 43 20 4c  |(C),C ADCHL,BC L|
       44 42 43 2c 28 29 20 5f  20 52 45 54 49 20 5f 20  |DBC,() _ RETI _ |
       4c 44 52 2c 41 20 49 4e  44 2c 28 43 29 20 4f 55  |LDR,A IND,(C) OU|
       54 28 43 29 2c 44 20 53  42 43 48 4c 2c 44 45 20  |T(C),D SBCHL,DE |
       4c 44 28 29 2c 44 45 20  5f 20 5f 20 49 4d 55 20  |LD(),DE _ _ IMU |
       4c 44 41 2c 49 20 49 4e  45 2c 28 43 29 20 4f 55  |LDA,I INE,(C) OU|
       54 28 43 29 2c 45 20 41  44 43 48 4c 2c 44 45 20  |T(C),E ADCHL,DE |
       4c 44 44 45 2c 28 29 20  5f 20 5f 20 49 4d 44 20  |LDDE,() _ _ IMD |
       4c 44 41 2c 52 20 49 4e  48 2c 28 43 29 20 4f 55  |LDA,R INH,(C) OU|
       54 28 43 29 2c 48 20 53  42 43 48 4c 2c 48 4c 20  |T(C),H SBCHL,HL |
       4c 44 28 29 2c 48 4c 20  5f 20 5f 20 5f 20 52 52  |LD(),HL _ _ _ RR|
       64 20 49 4e 4c 2c 28 43  29 20 4f 55 54 28 43 29  |d INL,(C) OUT(C)|
       2c 4c 20 41 44 43 48 4c  2c 48 4c 20 4c 44 48 4c  |,L ADCHL,HL LDHL|
       2c 28 29 20 5f 20 5f 20  5f 20 52 4c 64 20 49 4e  |,() _ _ _ RLd IN|
       46 2c 28 43 29 20 5f 20  53 42 43 48 4c 2c 53 50  |F,(C) _ SBCHL,SP|
       20 4c 44 28 29 2c 53 50  20 5f 20 5f 20 5f 20 5f  | LD(),SP _ _ _ _|
       20 49 4e 41 2c 28 43 29  20 4f 55 54 28 43 29 2c  | INA,(C) OUT(C),|
       41 20 41 44 43 48 4c 2c  53 50 20 4c 44 53 50 2c  |A ADCHL,SP LDSP,|
       28 29 20 5f 20 4c 44 49  20 43 50 49 20 49 4e 49  |() _ LDI CPI INI|
       20 4f 55 54 49 20 5f 20  5f 20 5f 20 5f 20 4c 44  | OUTI _ _ _ _ LD|
       44 20 43 50 2d 44 20 49  4e 44 20 4f 55 54 44 20  |D CP-D IND OUTD |
       5f 20 5f 20 5f 20 5f 20  4c 44 49 52 20 43 50 49  |_ _ _ _ LDIR CPI|
       52 20 49 4e 49 52 20 4f  54 49 52 20 5f 20 5f 20  |R INIR OTIR _ _ |
       5f 20 5f 20 4c 44 44 52  20 43 50 44 52 20 49 4e  |_ _ LDDR CPDR IN|
       44 52 20 4f 54 44 52 20  21 20 21 00 00 00 00 02  |DR OTDR ! !.....|
       
; In current memory relocation, label table starts at 43860.
; Format of each entry in the lable table is:
; - Type of label (1 byte): 
;   1= constant (label definition)
;   2= current address (label definition)
;   3= absolute jump, 2-byte op-code argument (label use)
;   4= relative jump (label use)
; - Value of the label (2 bytes)
; - Number of characters of the label (1 byte)
; - Characters of the label (n bytes)


